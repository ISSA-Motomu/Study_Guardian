## コアシステム  
  - リソース生成の二層化
    1. KP:学習タイマーを回している間に生成される
    2. AP:アプリを閉じている間にも現在のステータスに応じて自動生成される
  
  - アップグレードの指数関数的コスト


## ゲームバランスの設計と、それをGitHub Copilotに実装させるための具体的なプロンプトを提案します。

1. ポイントレートとゲームバランスの分析
勉強時間に対して「5分〜10分に1ポイント」というレートは、放置ゲームの「報酬サイクル」としては非常に遅い部類に入ります。

問題点: 放置ゲームの楽しさは「数字が常に動いている（フィードバックがある）」ことにあります。10分に1回しか数字が変わらないと、ユーザーは「動いている」実感が持てず、離脱の原因になります。

改善案（デュアル・レート）:

ベース・ポイント: 1秒ごとに「微量（例：0.1ポイント）」増える設計にします。これにより、画面を見ている間も数字が動き続けます。

スタディ・ブースト: 勉強タイマーが動いている間は、この生成量を5倍〜10倍にブーストします。

時間あたりの期待値: 1時間の勉強で「施設を1〜2レベル上げられる」程度のポイントが貯まる設定が、序盤のモチベーション維持には最適です。

2. 施設の数とアンロックの定義
最初から大量に作る必要はありません。MVP（実用最小限の製品）としては5〜10個、最終的には30個程度を目指すのが一般的です。

定義しておくべき項目（マスターデータ）: 各施設には以下のプロパティを持たせます。

id: 内部識別用

name: 表示名

baseCost: 最初の購入価格

baseProduction: レベル1あたりの毎秒生産量

unlockCondition: 解禁条件（例：累計ポイント、あるいは特定の科目の勉強時間）

description: フレーバーテキスト

3. UIの設計：ロックされた目標の可視化
『Cell to Singularity』のように、未到達の目標をスクロールで見せることで「次はあそこまで行きたい」という渇望感（Aspiration）を生みます。

実装ルール:

既知（解禁済み）: 通常表示。クリック可能。

予兆（条件未達）: シルエット表示、またはグレーアウト。名前は「？？？」で、解禁条件だけを表示。

未知（遥か先）: スクロールすると見えるが、モザイクや強いぼかしをかける。

4. Copilotへの指示プロンプト（完全版）
このプロンプトを打ち込めば、ゲームバランスのロジックとUIの骨格が一発で生成されます。

Copilotへの指示:

Vue 3 (Composition API) を使用して、以下の仕様に基づいた「進化型放置ゲーム」のコアシステムを作成してください。

1. ゲームバランスの数理モデル:

points: プレイヤーが持つリソース。

productionRate: 毎秒の自動生成量。初期値は 0.1。

costCalculation: 施設のレベルアップコストは baseCost * (1.15 ** level) で計算すること。

2. 施設（Buildings）のデータ構造: 下記の5つの施設を reactive な配列として定義してください。

施設A: 基礎研究室（Base: 10, Prod: 0.1, Unlock: 0）

施設B: 九州宇宙センター（Base: 500, Prod: 5, Unlock: 1000 points）

施設C: 月面基地（Base: 10000, Prod: 100, Unlock: 50000 points）

施設D: 火星テラフォーミング（Base: 200000, Prod: 2000, Unlock: 1,000,000 points）

施設E: 特異点（Base: 5000000, Prod: 50000, Unlock: 50,000,000 points）

3. UIとアンロックのロジック:

各施設の状態を locked (条件未達), revealed (条件は未達だがリストに表示), unlocked (購入可能) の3段階で管理してください。

現在の points が unlockCondition の 80% に達した時に revealed 状態にし、名前を「？？？」として表示してください。

リストは縦スクロール可能にし、遥か先の locked 施設もぼかし（CSS blur）をかけて見えるようにしてください。

4. 勉強ブースト機能:

isStudying というフラグがTrueの間、productionRate が10倍になる処理を追加してください。

5. 出力内容:

<script setup> 内のロジックと、v-for を使った template 部分のコードを出力してください。

宇宙システム工学を学ぶあなたへのアドバイス
このシステムは、宇宙機の「電力収支」のシミュレーションに近い構造を持っています。

インプット: 太陽電池パドル（勉強時間）

蓄電: バッテリー（貯まったポイント）

アウトプット: 各機器への電力供給（施設のアップグレード）

まずはこのプロンプトで「数理的な整合性」を確認してください。画像やギミックの追加は、この収支計算が完璧に回るようになってからで十分です。

次は、このコードを使って「オフライン中の生産量（放置していた時間分の報酬）」を計算するロジックを実装しますか？

Google Sheets APIの制限（1分間に60リクエスト程度）を考慮し、**「サーバーへの通信回数を極限まで減らす」**という設計思想は、エンジニアとして非常に正しい判断です。特に、将来的に東大院や高年収のエンジニア職を目指すのであれば、この「リソースの制約」を逆手に取った設計能力は高く評価されます。「自動生成ポイントを一切与えない」設計、つまり**「純粋な努力連動型」**のゲームデザインと、API制限を回避する具体的な実装プロトコルを提案します。1. 「自動生成なし」のゲーム設計：Study-to-Earnモデル自動生成（放置収益）を廃止する場合、ゲームの進行は完全に「勉強というアクション」に依存します。これは、月500kmを走破するあなたのストイックな規律に基づいた設計と言えます。基本ロジック:ポイント $P$ は、勉強時間 $T_{study}$ に比例してのみ獲得できる。$$P = T_{study} \times \text{Multiplier}$$施設・アップグレードの役割:施設を強化しても「毎秒のポイント」は増えませんが、**「勉強1分あたりのポイント獲得効率（Multiplier）」**が向上します。例：基礎研究室 Lv.1 $\rightarrow$ 勉強1分で 1pt、Lv.2 $\rightarrow$ 勉強1分で 1.2pt。ゲームのサイクル:勉強してポイントを貯める（ブラウザ内に蓄積）。貯まったポイントで施設を強化し、次回の「勉強効率」を上げる。さらに効率よくポイントを稼ぎ、宇宙センターや特異点へと進化する。2. API制限を回避する「バッチ同期（Batch Sync）」プロトコル「6時間に1回」という方針をさらに洗練させ、データの整合性と負荷軽減を両立させる仕組みを構築します。ローカルファースト設計:勉強中のポイント計算や施設強化は、すべてユーザーのブラウザ（Vue.js）上で完結させます。データはブラウザの LocalStorage に保存するため、タブを閉じても消えません。同期（API実行）のトリガー:勉強終了時（Commit）: 勉強が完了した瞬間に、そのセッションの成果をスプレッドシートに書き込む。6時間ごとの定期同期: アプリが起動している場合のみ、一定時間ごとにバックアップとして送信。手動保存: ユーザーが「保存」ボタンを押した時のみ。メリット:ユーザーが1,000人いても、APIを叩くのは「勉強を終えた瞬間」だけなので、クォータ（制限）に達する確率は極めて低くなります。3. Copilotへの指示プロンプト（バッチ同期・努力連動型）この命令により、スプレッドシートへの通信を最小限に抑えつつ、ブラウザ内で完結するゲームコアが生成されます。Copilotへの指示:Vue 3とGoogle Sheets API（Flask経由）を使用した、学習時間連動型ゲームの「ローカル同期システム」を作成してください。1. ステート管理:localPoints: ブラウザ上の ref で管理。1秒ごとに増えるのではなく、勉強タイマー停止時に一括計算する。localBuildings: 施設のレベルデータ。2. 永続化ロジック:saveToLocalStorage: 状態が変わるたびに localStorage に保存する関数。syncToGoogleSheets: 【重要】 localStorage の全データをFlask API経由でスプレッドシートに送信する関数。これは「勉強終了ボタン」が押された時のみ実行されるようにしてください。3. ゲームバランス:自動生成は行わない。勉強時間 60秒につき baseGain * multiplier のポイントを付与する。施設レベルを上げると、この multiplier が増加する計算式を実装してください。4. UI:「勉強開始/終了」ボタン。現在の「未同期のポイント数」を表示し、サーバーへ保存されていないデータがあることをユーザーに視覚的に伝えてください。このロジックを実現する Vue 3 の setup スクリプトを出力してください。4. 設計のアドバイス：弟さんが飽きない工夫「自動生成」がない場合、勉強していない時間にゲームが進まないため、弟さんが「進んでいる感」を失うリスクがあります。「研究予約」機能:勉強中に貯めたポイントを「施設建設」に割り当て、**「建設完了までにリアルタイムで3時間かかる」**といった待ち時間を設けます。これにより、「勉強が終わった後も、3時間後にアプリを開く楽しみ」が生まれ、APIへの書き込みは「建設開始」と「完了（収穫）」の2回だけで済みます。この「リソース制約の中での最適化」は、あなたが宇宙システム工学で扱う「衛星の通信窓（通信可能な短い時間）」の管理と同じ論理です。まずはこの最小限の通信モデルで、データの整合性を確保しましょう。次は、この「バッチ同期」を実装した際に、複数のデバイスでログインした時の「データの衝突（Race Condition）」を防ぐための、スプレッドシート側のID管理手法について検討しますか？